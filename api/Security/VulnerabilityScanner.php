<?php

declare(strict_types=1);

namespace Glueful\Security;

use Glueful\Logging\LogManager;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use RegexIterator;

/**
 * Standalone Vulnerability Scanner
 *
 * Comprehensive security vulnerability scanner that operates independently
 * without external extensions. Provides code analysis, dependency scanning,
 * and configuration security checks.
 *
 * @package Glueful\Security
 */
class VulnerabilityScanner
{
    /** @var LogManager|null Logger instance (lazy-loaded) */
    private ?LogManager $logger = null;

    /** @var array Scanner configuration */
    private array $config;

    /** @var string Application root path */
    private string $appRoot;

    /** @var string Storage path for vulnerability data */
    private string $storagePath;

    /** @var array Vulnerability patterns for code scanning */
    private array $vulnerabilityPatterns = [
        'sql_injection' => [
            '/\$_(GET|POST|REQUEST)\s*\[\s*[\'"][^\'"]*[\'"]\s*\]\s*[^;]*?(SELECT|INSERT|UPDATE|DELETE|DROP)/i',
            '/mysql_query\s*\(\s*[\'"][^\'"]*\$[^\'"]*[\'"]\s*\)/i',
            '/query\s*\(\s*[\'"][^\'"]*\$[^\'"]*[\'"]\s*\)/i',
            '/execute\s*\(\s*[\'"][^\'"]*\$[^\'"]*[\'"]\s*\)/i'
        ],
        'xss' => [
            '/echo\s+\$_(GET|POST|REQUEST)\[/i',
            '/print\s+\$_(GET|POST|REQUEST)\[/i',
            '/<\?=\s*\$_(GET|POST|REQUEST)\[/i',
            '/innerHTML\s*=\s*[\'"][^\'"]*\$[^\'"]*[\'"]/i'
        ],
        'path_traversal' => [
            '/include\s*\(\s*\$_(GET|POST|REQUEST)\[/i',
            '/require\s*\(\s*\$_(GET|POST|REQUEST)\[/i',
            '/file_get_contents\s*\(\s*\$_(GET|POST|REQUEST)\[/i',
            '/fopen\s*\(\s*\$_(GET|POST|REQUEST)\[/i'
        ],
        'command_injection' => [
            '/exec\s*\(\s*[\'"][^\'"]*\$[^\'"]*[\'"]\s*\)/i',
            '/system\s*\(\s*[\'"][^\'"]*\$[^\'"]*[\'"]\s*\)/i',
            '/shell_exec\s*\(\s*[\'"][^\'"]*\$[^\'"]*[\'"]\s*\)/i',
            '/passthru\s*\(\s*[\'"][^\'"]*\$[^\'"]*[\'"]\s*\)/i'
        ],
        'insecure_random' => [
            '/rand\s*\(\s*\)/i',
            '/mt_rand\s*\(\s*\)/i',
            '/srand\s*\(\s*\)/i'
        ],
        'weak_crypto' => [
            '/md5\s*\(/i',
            '/sha1\s*\(/i',
            '/crypt\s*\(/i',
            '/base64_encode\s*\(\s*\$password/i'
        ]
    ];

    /** @var array Known vulnerable packages */
    private array $knownVulnerablePackages = [
        'symfony/yaml' => ['< 3.4.47', '< 4.4.37', '< 5.4.9'],
        'doctrine/orm' => ['< 2.5.15', '< 2.6.6', '< 2.7.5'],
        'guzzlehttp/guzzle' => ['< 6.5.8', '< 7.4.5'],
        'laravel/framework' => ['< 6.20.44', '< 7.30.6', '< 8.83.27'],
        'twig/twig' => ['< 1.44.7', '< 2.15.3', '< 3.4.3']
    ];

    /**
     * Constructor - optimized for memory efficiency
     *
     * @param array $config Scanner configuration
     */
    public function __construct(array $config = [])
    {
        // Defer logger initialization until needed
        $this->config = array_merge($this->getDefaultConfig(), $config);
        $this->appRoot = dirname(dirname(dirname(__DIR__)));
        $this->storagePath = config('app.paths.storage') . 'vulnerability_scans';

        // Lazy directory creation - only when needed
        $this->ensureStorageDirectory();
    }

    /**
     * Run comprehensive vulnerability scan
     *
     * @param array $scanTypes Types of scans to run
     * @return array Scan results
     */
    public function scan(array $scanTypes = ['code', 'dependency', 'config']): array
    {
        $this->getLogger()->info('Starting vulnerability scan', ['scan_types' => $scanTypes]);

        $results = [
            'scan_id' => uniqid('scan_', true),
            'timestamp' => date('Y-m-d H:i:s'),
            'scan_types' => $scanTypes,
            'vulnerabilities' => [],
            'summary' => [
                'total_vulnerabilities' => 0,
                'critical' => 0,
                'high' => 0,
                'medium' => 0,
                'low' => 0
            ]
        ];

        try {
            if (in_array('code', $scanTypes)) {
                $results['code_scan'] = $this->performCodeScan();
                $results['vulnerabilities'] = array_merge(
                    $results['vulnerabilities'],
                    $results['code_scan']['vulnerabilities']
                );
            }

            if (in_array('dependency', $scanTypes)) {
                $results['dependency_scan'] = $this->performDependencyScan();
                $results['vulnerabilities'] = array_merge(
                    $results['vulnerabilities'],
                    $results['dependency_scan']['vulnerabilities']
                );
            }

            if (in_array('config', $scanTypes)) {
                $results['config_scan'] = $this->performConfigScan();
                $results['vulnerabilities'] = array_merge(
                    $results['vulnerabilities'],
                    $results['config_scan']['vulnerabilities']
                );
            }

            // Calculate summary
            $results['summary'] = $this->calculateSummary($results['vulnerabilities']);

            // Store results in JSON file
            $this->storeScanResultsToFile($results);

            $this->getLogger()->info('Vulnerability scan completed', [
                'scan_id' => $results['scan_id'],
                'total_vulnerabilities' => $results['summary']['total_vulnerabilities']
            ]);
        } catch (\Exception $e) {
            $this->getLogger()->error('Vulnerability scan failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            throw $e;
        }

        return $results;
    }

    /**
     * Perform code vulnerability scan
     *
     * @return array Code scan results
     */
    public function performCodeScan(): array
    {
        $this->getLogger()->info('Starting code vulnerability scan');

        $vulnerabilities = [];
        $scannedFiles = 0;

        $phpFiles = $this->getPhpFiles($this->appRoot);

        foreach ($phpFiles as $file) {
            $content = file_get_contents($file);
            $relativePath = str_replace($this->appRoot . '/', '', $file);

            foreach ($this->vulnerabilityPatterns as $type => $patterns) {
                foreach ($patterns as $pattern) {
                    if (preg_match_all($pattern, $content, $matches, PREG_OFFSET_CAPTURE)) {
                        foreach ($matches[0] as $match) {
                            $lineNumber = substr_count(substr($content, 0, (int)$match[1]), "\n") + 1;

                            $vulnerabilities[] = [
                                'type' => $type,
                                'severity' => $this->getSeverityForType($type),
                                'file' => $relativePath,
                                'line' => $lineNumber,
                                'code_snippet' => trim($match[0]),
                                'description' => $this->getDescriptionForType($type),
                                'recommendation' => $this->getRecommendationForType($type)
                            ];
                        }
                    }
                }
            }

            $scannedFiles++;
        }

        return [
            'scanned_files' => $scannedFiles,
            'vulnerabilities' => $vulnerabilities
        ];
    }

    /**
     * Perform dependency vulnerability scan
     *
     * @return array Dependency scan results
     */
    public function performDependencyScan(): array
    {
        $this->getLogger()->info('Starting dependency vulnerability scan');

        $vulnerabilities = [];
        $composerLockPath = $this->appRoot . '/composer.lock';

        if (!file_exists($composerLockPath)) {
            $this->getLogger()->warning('composer.lock not found', ['path' => $composerLockPath]);
            return [
                'scanned_packages' => 0,
                'vulnerabilities' => []
            ];
        }

        $composerData = json_decode(file_get_contents($composerLockPath), true);
        $packages = array_merge(
            $composerData['packages'] ?? [],
            $composerData['packages-dev'] ?? []
        );

        foreach ($packages as $package) {
            $packageName = $package['name'];
            $version = $package['version'];

            if (isset($this->knownVulnerablePackages[$packageName])) {
                $vulnerableVersions = $this->knownVulnerablePackages[$packageName];

                foreach ($vulnerableVersions as $vulnerableVersion) {
                    if (version_compare($version, ltrim($vulnerableVersion, '< '), '<')) {
                        $vulnerabilities[] = [
                            'type' => 'vulnerable_dependency',
                            'severity' => 'high',
                            'package' => $packageName,
                            'current_version' => $version,
                            'vulnerable_version' => $vulnerableVersion,
                            'description' => "Package {$packageName} version {$version} has known vulnerabilities",
                            'recommendation' => "Update {$packageName} to a version >= " .
                                              ltrim($vulnerableVersion, '< ')
                        ];
                    }
                }
            }
        }

        return [
            'scanned_packages' => count($packages),
            'vulnerabilities' => $vulnerabilities
        ];
    }

    /**
     * Perform configuration security scan
     *
     * @return array Configuration scan results
     */
    public function performConfigScan(): array
    {
        $this->getLogger()->info('Starting configuration security scan');

        $vulnerabilities = [];

        // Check environment file
        $envPath = $this->appRoot . '/.env';
        if (file_exists($envPath)) {
            $envContent = file_get_contents($envPath);

            // Check for debug mode in production
            if (preg_match('/APP_DEBUG\s*=\s*true/i', $envContent)) {
                $vulnerabilities[] = [
                    'type' => 'debug_mode_enabled',
                    'severity' => 'medium',
                    'file' => '.env',
                    'description' => 'Debug mode is enabled which can expose sensitive information',
                    'recommendation' => 'Set APP_DEBUG=false in production environments'
                ];
            }

            // Check for weak secret keys
            if (preg_match('/APP_KEY\s*=\s*(base64:)?(.{1,31})\s*$/m', $envContent, $matches)) {
                $vulnerabilities[] = [
                    'type' => 'weak_app_key',
                    'severity' => 'high',
                    'file' => '.env',
                    'description' => 'Application key appears to be weak or default',
                    'recommendation' => 'Generate a strong application key using php artisan key:generate'
                ];
            }
        }

        // Check file permissions
        $sensitiveFiles = ['.env', 'config/', 'storage/'];
        foreach ($sensitiveFiles as $file) {
            $filePath = $this->appRoot . '/' . $file;
            if (file_exists($filePath)) {
                $perms = fileperms($filePath);
                $octal = substr(sprintf('%o', $perms), -4);

                if ($octal > '0644' && is_file($filePath)) {
                    $vulnerabilities[] = [
                        'type' => 'insecure_file_permissions',
                        'severity' => 'medium',
                        'file' => $file,
                        'permissions' => $octal,
                        'description' => "File has overly permissive permissions ({$octal})",
                        'recommendation' => 'Set file permissions to 644 or more restrictive'
                    ];
                }
            }
        }

        return [
            'scanned_configs' => count($sensitiveFiles),
            'vulnerabilities' => $vulnerabilities
        ];
    }

    /**
     * Check for dependency vulnerabilities specifically
     *
     * @return array Dependency vulnerability results
     */
    public function checkDependencyVulnerabilities(): array
    {
        return $this->performDependencyScan();
    }

    /**
     * Get vulnerability statistics
     *
     * @return array Vulnerability statistics
     */
    public function getVulnerabilityStats(): array
    {
        try {
            $stats = ['critical' => 0, 'high' => 0, 'medium' => 0, 'low' => 0];
            $files = glob($this->storagePath . '/*.json');

            foreach ($files as $file) {
                $data = json_decode(file_get_contents($file), true);
                if ($data && isset($data['vulnerabilities'])) {
                    foreach ($data['vulnerabilities'] as $vulnerability) {
                        $severity = $vulnerability['severity'] ?? 'low';
                        if (isset($stats[$severity])) {
                            $stats[$severity]++;
                        }
                    }
                }
            }

            return $stats;
        } catch (\Exception $e) {
            $this->getLogger()->error('Failed to get vulnerability stats', ['error' => $e->getMessage()]);
            return ['critical' => 0, 'high' => 0, 'medium' => 0, 'low' => 0];
        }
    }

    /**
     * Get recent vulnerabilities
     *
     * @param int $limit Number of vulnerabilities to return
     * @return array Recent vulnerabilities
     */
    public function getRecentVulnerabilities(int $limit = 10): array
    {
        try {
            $allVulnerabilities = [];
            $files = glob($this->storagePath . '/*.json');

            // Sort files by modification time (newest first)
            usort($files, function ($a, $b) {
                return filemtime($b) - filemtime($a);
            });

            foreach ($files as $file) {
                $data = json_decode(file_get_contents($file), true);
                if ($data && isset($data['vulnerabilities'])) {
                    foreach ($data['vulnerabilities'] as $vulnerability) {
                        $vulnerability['scan_id'] = $data['scan_id'];
                        $vulnerability['detected_at'] = $data['timestamp'];
                        $allVulnerabilities[] = $vulnerability;
                    }
                }

                if (count($allVulnerabilities) >= $limit) {
                    break;
                }
            }

            return array_slice($allVulnerabilities, 0, $limit);
        } catch (\Exception $e) {
            $this->getLogger()->error('Failed to get recent vulnerabilities', ['error' => $e->getMessage()]);
            return [];
        }
    }

    /**
     * Update vulnerability status
     *
     * @param string $vulnerabilityId Vulnerability ID
     * @param string $status New status
     * @return bool Success status
     */
    public function updateVulnerabilityStatus(string $vulnerabilityId, string $status): bool
    {
        try {
            $files = glob($this->storagePath . '/*.json');

            foreach ($files as $file) {
                $data = json_decode(file_get_contents($file), true);
                if ($data && isset($data['vulnerabilities'])) {
                    $updated = false;

                    foreach ($data['vulnerabilities'] as &$vulnerability) {
                        if (($vulnerability['id'] ?? '') === $vulnerabilityId) {
                            $vulnerability['status'] = $status;
                            $vulnerability['updated_at'] = date('Y-m-d H:i:s');
                            $updated = true;
                            break;
                        }
                    }

                    if ($updated) {
                        file_put_contents($file, json_encode($data, JSON_PRETTY_PRINT));
                        return true;
                    }
                }
            }

            return false;
        } catch (\Exception $e) {
            $this->getLogger()->error('Failed to update vulnerability status', [
                'vulnerability_id' => $vulnerabilityId,
                'status' => $status,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Get all stored scan results
     *
     * @param int $limit Number of scans to return
     * @return array Scan results
     */
    public function getAllScanResults(int $limit = 20): array
    {
        try {
            $files = glob($this->storagePath . '/*.json');

            // Sort files by modification time (newest first)
            usort($files, function ($a, $b) {
                return filemtime($b) - filemtime($a);
            });

            $results = [];
            $files = array_slice($files, 0, $limit);

            foreach ($files as $file) {
                $data = json_decode(file_get_contents($file), true);
                if ($data) {
                    $results[] = [
                        'scan_id' => $data['scan_id'],
                        'timestamp' => $data['timestamp'],
                        'scan_types' => $data['scan_types'],
                        'summary' => $data['summary'],
                        'file' => basename($file)
                    ];
                }
            }

            return $results;
        } catch (\Exception $e) {
            $this->getLogger()->error('Failed to get scan results', ['error' => $e->getMessage()]);
            return [];
        }
    }

    /**
     * Get scan result by ID
     *
     * @param string $scanId Scan ID
     * @return array|null Scan result
     */
    public function getScanById(string $scanId): ?array
    {
        try {
            $files = glob($this->storagePath . '/*_' . $scanId . '.json');

            if (empty($files)) {
                return null;
            }

            $data = json_decode(file_get_contents($files[0]), true);
            return $data ?: null;
        } catch (\Exception $e) {
            $this->getLogger()->error('Failed to get scan by ID', [
                'scan_id' => $scanId,
                'error' => $e->getMessage()
            ]);
            return null;
        }
    }

    /**
     * Delete old scan files
     *
     * @param int $daysToKeep Number of days to keep files
     * @return int Number of files deleted
     */
    public function cleanupOldScans(int $daysToKeep = 30): int
    {
        try {
            $files = glob($this->storagePath . '/*.json');
            $cutoffTime = time() - ($daysToKeep * 24 * 60 * 60);
            $deletedCount = 0;

            foreach ($files as $file) {
                if (filemtime($file) < $cutoffTime) {
                    if (unlink($file)) {
                        $deletedCount++;
                        $this->getLogger()->info('Deleted old scan file', ['file' => basename($file)]);
                    }
                }
            }

            return $deletedCount;
        } catch (\Exception $e) {
            $this->getLogger()->error('Failed to cleanup old scans', ['error' => $e->getMessage()]);
            return 0;
        }
    }

    /**
     * Export vulnerabilities to CSV
     *
     * @param string $outputPath Output file path
     * @param array $scanIds Optional scan IDs to filter
     * @return bool Success status
     */
    public function exportToCSV(string $outputPath, array $scanIds = []): bool
    {
        try {
            $vulnerabilities = [];
            $files = glob($this->storagePath . '/*.json');

            foreach ($files as $file) {
                $data = json_decode(file_get_contents($file), true);
                if ($data && isset($data['vulnerabilities'])) {
                    // Filter by scan IDs if specified
                    if (!empty($scanIds) && !in_array($data['scan_id'], $scanIds)) {
                        continue;
                    }

                    foreach ($data['vulnerabilities'] as $vulnerability) {
                        $vulnerability['scan_id'] = $data['scan_id'];
                        $vulnerability['detected_at'] = $data['timestamp'];
                        $vulnerabilities[] = $vulnerability;
                    }
                }
            }

            if (empty($vulnerabilities)) {
                return false;
            }

            $fp = fopen($outputPath, 'w');

            // Write header
            $headers = ['scan_id', 'type', 'severity', 'file', 'line', 'description', 'recommendation', 'detected_at'];
            fputcsv($fp, $headers);

            // Write data
            foreach ($vulnerabilities as $vulnerability) {
                $row = [];
                foreach ($headers as $header) {
                    $row[] = $vulnerability[$header] ?? '';
                }
                fputcsv($fp, $row);
            }

            fclose($fp);
            return true;
        } catch (\Exception $e) {
            $this->getLogger()->error('Failed to export to CSV', ['error' => $e->getMessage()]);
            return false;
        }
    }

    /**
     * Get PHP files for scanning
     *
     * @param string $directory Directory to scan
     * @return array PHP file paths
     */
    private function getPhpFiles(string $directory): array
    {
        $files = [];
        $excludeDirs = ['vendor', 'node_modules', 'storage/cache', 'storage/logs'];

        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($directory, RecursiveDirectoryIterator::SKIP_DOTS)
        );

        $phpFiles = new RegexIterator($iterator, '/\.php$/i');

        foreach ($phpFiles as $file) {
            $relativePath = str_replace($directory . '/', '', $file->getPathname());

            $shouldExclude = false;
            foreach ($excludeDirs as $excludeDir) {
                if (strpos($relativePath, $excludeDir) === 0) {
                    $shouldExclude = true;
                    break;
                }
            }

            if (!$shouldExclude) {
                $files[] = $file->getPathname();
            }
        }

        return $files;
    }

    /**
     * Get severity for vulnerability type
     *
     * @param string $type Vulnerability type
     * @return string Severity level
     */
    private function getSeverityForType(string $type): string
    {
        $severityMap = [
            'sql_injection' => 'critical',
            'xss' => 'high',
            'path_traversal' => 'high',
            'command_injection' => 'critical',
            'insecure_random' => 'medium',
            'weak_crypto' => 'high'
        ];

        return $severityMap[$type] ?? 'low';
    }

    /**
     * Get description for vulnerability type
     *
     * @param string $type Vulnerability type
     * @return string Description
     */
    private function getDescriptionForType(string $type): string
    {
        $descriptions = [
            'sql_injection' => 'Potential SQL injection vulnerability detected',
            'xss' => 'Potential Cross-Site Scripting (XSS) vulnerability detected',
            'path_traversal' => 'Potential path traversal vulnerability detected',
            'command_injection' => 'Potential command injection vulnerability detected',
            'insecure_random' => 'Use of insecure random number generation detected',
            'weak_crypto' => 'Use of weak cryptographic functions detected'
        ];

        return $descriptions[$type] ?? 'Security vulnerability detected';
    }

    /**
     * Get recommendation for vulnerability type
     *
     * @param string $type Vulnerability type
     * @return string Recommendation
     */
    private function getRecommendationForType(string $type): string
    {
        $recommendations = [
            'sql_injection' => 'Use prepared statements and parameterized queries',
            'xss' => 'Sanitize and escape user input before output',
            'path_traversal' => 'Validate and sanitize file paths, use basename()',
            'command_injection' => 'Avoid executing user input, use escapeshellarg()',
            'insecure_random' => 'Use random_bytes() or random_int() for secure randomness',
            'weak_crypto' => 'Use password_hash() for passwords and strong algorithms for encryption'
        ];

        return $recommendations[$type] ?? 'Review and fix the security issue';
    }

    /**
     * Calculate vulnerability summary
     *
     * @param array $vulnerabilities List of vulnerabilities
     * @return array Summary statistics
     */
    private function calculateSummary(array $vulnerabilities): array
    {
        $summary = [
            'total_vulnerabilities' => count($vulnerabilities),
            'critical' => 0,
            'high' => 0,
            'medium' => 0,
            'low' => 0
        ];

        foreach ($vulnerabilities as $vulnerability) {
            $severity = $vulnerability['severity'] ?? 'low';
            if (isset($summary[$severity])) {
                $summary[$severity]++;
            }
        }

        return $summary;
    }

    /**
     * Store scan results in JSON file
     *
     * @param array $results Scan results
     * @return void
     */
    private function storeScanResultsToFile(array $results): void
    {
        try {
            // Add unique IDs to vulnerabilities
            foreach ($results['vulnerabilities'] as &$vulnerability) {
                $vulnerability['id'] = uniqid('vuln_', true);
                $vulnerability['status'] = 'open';
                $vulnerability['detected_at'] = $results['timestamp'];
            }

            // Create filename with date and scan ID
            $date = date('Y-m-d');
            $filename = $date . '_' . $results['scan_id'] . '.json';
            $filepath = $this->storagePath . '/' . $filename;

            // Store the complete scan results
            $success = file_put_contents($filepath, json_encode($results, JSON_PRETTY_PRINT));

            if ($success) {
                $this->getLogger()->info('Scan results stored to file', [
                    'file' => $filename,
                    'vulnerabilities_count' => count($results['vulnerabilities'])
                ]);
            } else {
                throw new \Exception('Failed to write scan results to file');
            }
        } catch (\Exception $e) {
            $this->getLogger()->error('Failed to store scan results to file', [
                'scan_id' => $results['scan_id'],
                'error' => $e->getMessage()
            ]);
        }
    }

    /**
     * Get default configuration
     *
     * @return array Default configuration
     */
    private function getDefaultConfig(): array
    {
        return [
            'max_scan_time' => 300, // 5 minutes
            'exclude_directories' => ['vendor', 'node_modules', 'storage/cache'],
            'risk_threshold' => [
                'critical' => 0,
                'high' => 5,
                'medium' => 20,
                'low' => 50
            ],
            'enable_dependency_scan' => true,
            'enable_code_scan' => true,
            'enable_config_scan' => true
        ];
    }

    /**
     * Get logger instance (lazy-loaded)
     *
     * @return LogManager
     */
    private function getLogger(): LogManager
    {
        if ($this->logger === null) {
            $this->logger = new LogManager('vulnerability_scanner');
            // Log initialization only once when logger is first created
            $this->logger->info('VulnerabilityScanner initialized', [
                'app_root' => $this->appRoot,
                'storage_path' => $this->storagePath,
                'config' => $this->config
            ]);
        }
        return $this->logger;
    }

    /**
     * Ensure storage directory exists (lazy creation)
     *
     * @return void
     */
    private function ensureStorageDirectory(): void
    {
        if (!is_dir($this->storagePath)) {
            mkdir($this->storagePath, 0755, true);
        }
    }

    /**
     * Clean up resources to prevent memory leaks
     *
     * @return void
     */
    public function cleanup(): void
    {
        $this->logger = null;
        // Clear large arrays to free memory
        $this->vulnerabilityPatterns = [];
        $this->knownVulnerablePackages = [];
    }

    /**
     * Destructor - ensure cleanup
     */
    public function __destruct()
    {
        $this->cleanup();
    }
}
